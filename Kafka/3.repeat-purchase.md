# 3.重复消费

## 重复消费

1.写入数据库之前用主键查一下，如果数据已有，改为update
2.如果写入的是redis，没问题，直接set即可，天然幂等性
3.生产者发送数据的时候生成一个全局唯一ID，消费者写入redis之前先根据ID查一下，如果消费过了，就不必处理了
4.基于数据库做唯一键来保证不会重复插入，重复插入的时候报异常，不会插进去

## 保证消息的顺序性

1.1个topic,一个partition,一个consumer，内部单线程消费；但是单线程吞吐量太低，一般不用
2.写N个内存queue，具有相同key的数据都存到同一个内存queue；对于N个线程，每个线程分别消费一个内存queue即可

## 消息队列满了或消息队列积压

1.先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停掉
2.新建一个topic，partition是原来的10倍，临时建立好原先10倍的queue的数量
3.然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍的queue
4.临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据
5.等快速消费完积压数据之后，得先恢复原先部署的架构，重新用原来的consumer机器来消费消息
