# 1.List,Set,Map的区别

* List：接口存储一组不唯一，有序的集合
* Set: 不允许重复的集合，不会有多个元素引用相同的对象
* Map: 使用键值对存储，Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型但也可以是对象

## ArrayList与LinkedList区别

1.是否保证线程安全：ArrayList和LinkedList都是不同步的，都不保证线程安全
2.底层数据结构：ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构
3.插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置影响，例如add(e)方法的时候，ArrayList默认在将指定的元素追加到此列表的末尾，时间复杂度为O(1)，但是如果要在指定位置i插入和删除元素的话(add(i,e))，时间复杂度为O(n-i)。因为在进行上述操作的时候集合中第i和第i个元素之后的n-i个元素都要执行向后移一位的操作。LinkedList采用链表存储，所以对于add(e)方法的插入，删除元素的时间复杂度不受元素位置影响，近似O(1)，如果是要在指定位置i插入和删除元素的话(add(i,e))，时间复杂度近似为O(N),因为要先移动到指定的位置再插入
4.是否支持快速随机访问：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问是通过元素的序号快速获取元素对象（get(i)）
5.内存空间占用：ArrayList的空间浪费主要体现在List列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比AraayList更多的空间（存储后继与前驱的数据指向）

## ArrayList与Vector的区别

1.Vector类的所有方法都是同步的，运行效率会比ArrayList低

## HashMap与Hashtable的区别

1.HashMap是线程非安全的，HashTable是线程安全的；HashTable内部的方法都是加过synchronized修饰的
2.效率：因为线程安全的问题，HashMap比HashTable的效率高一点
3.Null Key与Null Value的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键锁对应的值为null；Hashtable中，key不能为null，否则直接抛出NullPointerException。
4. 初始容量大小与每次扩容大小的不同：创建时如果不指定容量初始值，HashTable默认的初始化大小为11，之后每次扩容容量变为原来的2N+1，HashMap默认初始化为16，之后每次扩容，变为原来的2倍；
创建时如果给定了容量初始值，HashTable会直接使用给定的大小，而HashMap会将其扩充为2的幂次方大小
5.底层数据结构：JDK1.8后的HashMap在解决哈希冲突时有了较大变化，当链表长度大于阈值（默认8）时，将列表转为红黑树，以减少搜索时间。HashTable没有这样的机制

## HashMap与HashSet的区别

HashSet的底层是基于HashMap编写的，HashSet仅实现了clone(),writeObject,readObject()方法，其它都是基于HashMap实现  

## HashSet如何去重

当把对象加入到HashMap的时候,HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值做比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果有相同的hashcode值存在，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功

### hashCode()与equals()的相关规定

1.如果两个对象相等，则hashcode一定也是相同的
2.两个对象相等，对两个equals方法返回true
3.两个对象有相同的hashcode值，他们也不一定是相等的
4.综上，equals方法被覆盖过，则hashcode方法也必须被覆盖
5.hashCode()的行为是对堆上的对象产生独特值。如果没有重写hashCode(),则该class的两个对象无论如何都不会相等