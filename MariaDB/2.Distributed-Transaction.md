# 2.分布式事务

AT TCC SAGA XA事务

## 1.AT模式

(1) 基于支持本地ACID事务的关系型数据库，Java应用，通过JDBC访问数据库
(2) 两阶段提交协议：(1)业务数据与回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源
(3)                 (2)提交异步化（成功），回滚通过一阶段的回滚进行反向补偿（失败）
(4) 写隔离：一阶段事务提交前，必须拿到全局锁
(5) 读隔离：采用select for update来实现读已提交的隔离级别；执行时会申请全局锁，如果全局锁被其它事务持有，则回滚并重试

## 2.TCC模式（全称是Try Confirm Cancel）

事务满足两阶段提交模型的要求

* Try阶段： 这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留
* Confirm阶段：这个阶段说的是在各个服务中执行实际的操作
* Cancel阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作（把那些执行成功的回滚）

此种方法严重依赖于自己写代码来回滚和补偿，会造成补偿代码巨大

（1） 一阶段prepare行为
（2） 二阶段commit或rollback行为

AT模式与TCC模式的区别
（1）AT模式基于本地ACID事务的关系型数据库
一阶段prepare行为：本地事务中，一并提交业务数据更新和相应回滚日志记录
二阶段commit行为：马上成功结束，自动异步批量清理回滚日志
二阶段rollback行为：通过回滚日志，自动生成补偿操作，完成数据回滚
（2）TCC模式，不依赖于底层数据资源的数据支持
一阶段prepare行为：调用自定义的prepare逻辑
二阶段commit行为：调用自定义的commit逻辑
二阶段rollback行为：调用自定义的rollback逻辑

## 3.XA模式

* 首先有个事务管理器，负责协调多个数据库（资源管理器）的事务，事务管理器先问各个数据库都准备好了么，如果每个数据库都回复OK，那么就正式提交事务，在各个数据库上操作执行；如果其中任何一个数据库回答不ok，那么就回滚事务；
* 比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景，使用Spring + JTA就可以实现
* 这个方案很少用，因为某个系统内部如果出现了跨多个库的操作，是不合规的，按照规范，每个微服务只能操作自己对应的一个数据库
* 如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，随便交叉胡乱访问，几百个服务的话，全体乱套，这样的微服务是没发管理的，没发治理的，可能出现数据被别人改错，自己的库被别人写挂等情况,如果你要操作别人的数据库，你必须通过调用别的服务的接口来实现，决不允许交叉别人的数据库

## 4.Saga模式

(1) 基本原理：业务流程中每个参与者都提交本地事务，若一个事务参与者失败，则补偿前面已经成功的参与者

(2) 使用场景: 不需要强一致性的事务处理，只需要保证最终一致性即可

(3) 优势：一阶段提交本地事务，无锁，高性能；参与者可以异步执行，高吞吐；补偿服务易于实现，因为一个更新操作的反向操作更容易理解

(4) 劣势：不保证事务的隔离性

## 5.可靠消息最终一致性方案（RocketMQ）

(1) A系统发送一个prepare消息到mq，如果消息发送失败就取消执行
(2) 如果消息发送成功了，那么接着执行本地事务，如果成功则告诉mq发送确认信息，失败则告诉mq回滚消息
(3) 如果发送了确认消息，此时B系统会接收到确认消息，可以执行B系统的本地事务
(4) mq会自动定时轮询所有prepare消息回调你的接口，确认是否本地事务处理失败了，所以没有发送确认消息，是重试还是回滚？一般来说可以查下本地事务是否执行，如果本地事务回滚了，那就通知回滚
(5) 如果B事务失败了，则继续重试直到成功，想办法通知A也回滚