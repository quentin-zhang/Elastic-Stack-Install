# 2.分布式事务

AT TCC SAGA XA事务

## 1.AT模式

(1) 基于支持本地ACID事务的关系型数据库，Java应用，通过JDBC访问数据库
(2) 两阶段提交协议：(1)业务数据与回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源
(3)                 (2)提交异步化（成功），回滚通过一阶段的回滚进行反向补偿（失败）
(4) 写隔离：一阶段事务提交前，必须拿到全局锁
(5) 读隔离：采用select for update来实现读已提交的隔离级别；执行时会申请全局锁，如果全局锁被其它事务持有，则回滚并重试

## 2.TCC模式

事务满足两阶段提交模型的要求
（1） 一阶段prepare行为
（2） 二阶段commit或rollback行为

AT模式与TCC模式的区别
（1）AT模式基于本地ACID事务的关系型数据库
一阶段prepare行为：本地事务中，一并提交业务数据更新和相应回滚日志记录
二阶段commit行为：马上成功结束，自动异步批量清理回滚日志
二阶段rollback行为：通过回滚日志，自动生成补偿操作，完成数据回滚
（2）TCC模式，不依赖于底层数据资源的数据支持
一阶段prepare行为：调用自定义的prepare逻辑
二阶段commit行为：调用自定义的commit逻辑
二阶段rollback行为：调用自定义的rollback逻辑

## 3.XA模式

(1) 首先有个事务管理器
(2) 第一个阶段是询问
(3) 第二个阶段是执行（各个数据库都准备好了就提交，如果有一个没准备好，那就回滚）
(4) Spring + JTA可以实现

## 4.Saga模式

(1) 基本原理：业务流程中每个参与者都提交本地事务，若一个事务参与者失败，则补偿前面已经成功的参与者

(2) 使用场景: 不需要强一致性的事务处理，只需要保证最终一致性即可

(3) 优势：一阶段提交本地事务，无锁，高性能；参与者可以异步执行，高吞吐；补偿服务易于实现，因为一个更新操作的反向操作更容易理解

(4) 劣势：不保证事务的隔离性

## 5.可靠消息最终一致性方案（RocketMQ）

(1) A系统发送一个prepare消息到mq，如果消息发送失败就取消执行
(2) 如果消息发送成功了，那么接着执行本地事务，如果成功则告诉mq发送确认信息，失败则告诉mq回滚消息
(3) 如果发送了确认消息，此时B系统会接收到确认消息，可以执行B系统的本地事务
(4) mq会自动定时轮询所有prepare消息回调你的接口，确认是否本地事务处理失败了，所以没有发送确认消息，是重试还是回滚？一般来说可以查下本地事务是否执行，如果本地事务回滚了，那就通知回滚
(5) 如果B事务失败了，则继续重试直到成功，想办法通知A也回滚